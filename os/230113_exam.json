[
	{
			"question": "Which of the following operations is allowed in user mode?",
			"options": [
					"Directly access a sector on a disk (i.e., directly access the hardware)",
					"None of the listed operations is allowed in user mode",
					"Turn off interrupts",
					"Modify the interrupt vector (interrupt descriptor table)",
					"Change the page table"
			],
			"answer": "None of the listed operations is allowed in user mode",
			"explanation": "User mode is a restricted mode where critical operations like directly accessing hardware or modifying system settings are not allowed to ensure system stability and security."
	},
	{
			"question": "What is the main difference between preemptive and non-preemptive scheduling?",
			"options": [
					"If the process/thread with the highest priority is scheduled first or not.",
					"If a process is allowed to fork child processes or not",
					"If the process executes in an isolated memory space or not.",
					"If the process/thread with the shortest remaining execution time is scheduled first or not.",
					"If a process/thread gives up the CPU (and let some other execute instead) voluntarily or not."
			],
			"answer": "If a process/thread gives up the CPU (and let some other execute instead) voluntarily or not.",
			"explanation": "In preemptive scheduling, the operating system can forcibly take the CPU from a process, whereas in non-preemptive scheduling, the process must voluntarily give up the CPU."
	},
	{
			"question": "Which of the following events will take place when switching from one process (old) to another (new)?",
			"options": [
					"Remove all virtual memory pages of the old process from the main memory.",
					"Turn off the interrupts when the new process is restarted.",
					"Copy data from the PCB of the new process into the interrupt vector table.",
					"Store CPU register states of the old process into the PCB.",
					"All of the events happen"
			],
			"answer": "Store CPU register states of the old process into the PCB.",
			"explanation": "During a context switch, the CPU register states of the old process are saved into the Process Control Block (PCB) to preserve its state for when it is resumed later."
	},
	{
			"question": "Given a system with n runnable processes. In how many ways can we schedule these processes, i.e., in how many orders can we execute them?",
			"options": [
					"n!",
					"2n",
					"nÂ²",
					"n log n",
					"n^3"
			],
			"answer": "n!",
			"explanation": "The number of ways to schedule n processes is n factorial (n!), which represents all possible permutations of the process execution order."
	},
	{
			"question": "Which of the following alternatives is a disadvantage of priority scheduling?",
			"options": [
					"It usually decreases the CPU utilization",
					"It always favors CPU-bound processes",
					"All of the alternatives are disadvantages with priority scheduling",
					"Priority scheduling can never be used in multiprocessor systems",
					"Some processes may not be executed at all if the load is very high"
			],
			"answer": "Some processes may not be executed at all if the load is very high",
			"explanation": "In priority scheduling, low-priority processes can suffer from starvation if high-priority processes continuously occupy the CPU, especially under heavy load."
	},
	{
			"question": "Which of the following alternatives is a mechanism / technique for inter-process communication (IPC)?",
			"options": [
					"Contiguous synchronization",
					"Hardware interrupt",
					"Message-passing",
					"None of the other alternatives",
					"Dual-mode operation"
			],
			"answer": "Message-passing",
			"explanation": "Message-passing is a common IPC technique that allows processes to communicate by sending and receiving messages, which is useful for coordinating activities between processes."
	},
	{
			"question": "What is the purpose of a memory management unit (MMU)?",
			"options": [
					"Allocate dynamic memory on the heap",
					"Manage the graphics memory in 3D-graphics applications",
					"Manage the swap space on disk",
					"Keep track of free blocks on the disk",
					"Translate virtual (logical) addresses to physical addresses in memory"
			],
			"answer": "Translate virtual (logical) addresses to physical addresses in memory",
			"explanation": "The MMU translates virtual addresses generated by programs into physical addresses used by the hardware, facilitating efficient memory management and isolation."
	},
	{
			"question": "Assume a page-based virtual memory system with 8kB pages. An operating system designer would like to decrease the page size to 2kB. Which of the following alternatives is true if the page size is decreased to 2kB?",
			"options": [
					"Internal fragmentation increases",
					"External fragmentation increases",
					"Both external and internal fragmentation increase",
					"Internal fragmentation decreases",
					"Neither internal nor external fragmentation are affected"
			],
			"answer": "Internal fragmentation decreases",
			"explanation": "Decreasing the page size reduces internal fragmentation because less memory is wasted within each allocated page, although it may increase the overhead of managing more pages."
	},
	{
			"question": "Which of the following terms below refers to a method used for allocation of disk space for a file?",
			"options": [
					"Page-based allocation",
					"Virtual allocation",
					"Segmented allocation",
					"Buddy-block allocation",
					"None of the alternatives is a valid allocation method"
			],
			"answer": "None of the alternatives is a valid allocation method",
			"explanation": "The listed methods are not standard terms for disk space allocation. Common methods include contiguous, linked-list, and indexed allocation."
	},
	{
			"question": "Which of the following devices is a typical character device?",
			"options": [
					"None of the alternatives is a character device",
					"High-resolution display",
					"CD-ROM drive",
					"Solid-state disk",
					"Keyboard"
			],
			"answer": "Keyboard",
			"explanation": "Character devices, like keyboards, transmit data one character at a time, in contrast to block devices, which manage data in fixed-size blocks."
	},
	{
			"question": "Your system is running slow and the response times are long. Which of the following alternatives might have happened?",
			"options": [
					"Your computer receives a lot of network traffic",
					"The number of read / write requests to your disk is very high",
					"All alternatives are possible",
					"You have too many active large processes",
					"Your main memory is too small to fit the total working set"
			],
			"answer": "All alternatives are possible",
			"explanation": "System slowdowns can be caused by various factors, including high network traffic, excessive disk I/O, large active processes, or insufficient memory."
	},
	{
			"question": "Which of the following alternatives is a way to prevent deadlocks?",
			"options": [
					"All of the alternatives prevent deadlocks",
					"Execute only one process at a time, i.e., no concurrency is allowed (multiple processes may be ready or blocked, but only one is running)",
					"Allocate all resources in a specific order",
					"Make transactions indivisible",
					"Use semaphores to protect all shared resources"
			],
			"answer": "All of the alternatives prevent deadlocks",
			"explanation": "Deadlocks can be prevented by ensuring that one or more of the conditions necessary for deadlocks do not hold, which these techniques aim to achieve."
	}
]
