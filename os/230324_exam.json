[
	{
			"question": "Which of the following operations is allowed in user mode?",
			"options": [
					"Read an entry in the page table",
					"Modify the stack pointer",
					"All of the listed operations are allowed in user mode",
					"Execute a library call",
					"Allocate memory on the heap"
			],
			"answer": "Execute a library call",
			"explanation": "In user mode, operations that directly interact with hardware or modify critical system settings are restricted. However, executing a library call, which is part of user-level programming, is allowed."
	},
	{
			"question": "Which of the following operations will result in a system call in a normal operating system?",
			"options": [
					"Allocating dynamic memory on the heap",
					"Reading a file from disk",
					"Executing a conditional branch instruction",
					"None of the alternatives",
					"Push variables on the thread's stack"
			],
			"answer": "Reading a file from disk",
			"explanation": "Reading a file from disk requires the operating system to interact with hardware, which involves a system call. The other operations listed are managed at the user level and do not typically trigger a system call."
	},
	{
			"question": "Protection is needed in many places in a computer system, e.g., for the processor ('CPU protection'). How can we implement CPU protection?",
			"options": [
					"Protecting the interrupt vector from user-mode access",
					"Using dual-mode operation (user-mode and kernel-mode)",
					"Using semaphores",
					"None of the alternatives provide CPU protection",
					"Using a timer and clock interrupts"
			],
			"answer": "Using a timer and clock interrupts",
			"explanation": "CPU protection can be implemented using a timer and clock interrupts to ensure that no single process can monopolize the CPU, thereby preventing issues such as infinite loops or system hangs."
	},
	{
			"question": "What is the main difference between preemptive and non-preemptive scheduling?",
			"options": [
					"If a process/thread gives up the CPU (and let some other execute instead) voluntarily or not.",
					"If the process executes in an isolated memory space or not.",
					"If the process/thread with the shortest remaining execution time is scheduled first or not.",
					"If a process is allowed to fork child processes or not",
					"If the process/thread with the highest priority is scheduled first or not"
			],
			"answer": "If a process/thread gives up the CPU (and let some other execute instead) voluntarily or not.",
			"explanation": "In preemptive scheduling, the operating system can forcibly take the CPU from a process, whereas in non-preemptive scheduling, the process must voluntarily give up the CPU."
	},
	{
			"question": "Given a system with n runnable processes. In how many ways can we schedule these processes, i.e., in how many orders can we execute them?",
			"options": [
					"n log n",
					"n²",
					"n³",
					"n!",
					"2n"
			],
			"answer": "n!",
			"explanation": "The number of ways to schedule n processes is n factorial (n!), representing all possible permutations of the process execution order."
	},
	{
			"question": "Which of the following alternatives is a way to prevent deadlocks?",
			"options": [
					"Execute only one process at a time, i.e., no concurrency is allowed (multiple processes may be ready or blocked, but only one is running)",
					"All of the alternatives prevent deadlocks",
					"Make transactions indivisible",
					"Allocate all resources in a specific order",
					"Use semaphores to protect all shared resources"
			],
			"answer": "All of the alternatives prevent deadlocks",
			"explanation": "Deadlocks can be prevented by ensuring that one or more of the conditions necessary for deadlocks do not hold, which these techniques aim to achieve."
	},
	{
			"question": "What is the purpose of a memory management unit (MMU)?",
			"options": [
					"Allocate dynamic memory on the heap",
					"Keep track of free blocks on the disk",
					"Manage the graphics memory in 3D-graphics applications",
					"Translate virtual (logical) addresses to physical addresses in memory",
					"Manage the swap space on disk"
			],
			"answer": "Translate virtual (logical) addresses to physical addresses in memory",
			"explanation": "The MMU translates virtual addresses generated by programs into physical addresses used by the hardware, facilitating efficient memory management and isolation."
	},
	{
			"question": "A TLB (translation look-aside buffer) improves performance by",
			"options": [
					"Storing the most recently used disk blocks in main memory",
					"Looking in the interrupt vector in advance and thus can handle interrupts faster",
					"Using a small table of the most recent translations between logical and physical addresses",
					"All alternatives are used",
					"Keeping track of which virtual pages are stored where on the external disk"
			],
			"answer": "Using a small table of the most recent translations between logical and physical addresses",
			"explanation": "A TLB is a cache that stores recent translations of virtual to physical addresses, allowing the system to quickly translate addresses without accessing the page table each time, thus improving performance."
	},
	{
			"question": "Which of the following terms below does not refer to a method used for allocation of disk space for a file?",
			"options": [
					"Indexed (i-node) allocation",
					"All alternatives are valid allocation methods",
					"Linked-list allocation",
					"Virtual allocation",
					"Contiguous allocation"
			],
			"answer": "Virtual allocation",
			"explanation": "Virtual allocation is not a standard method for disk space allocation. Common methods include indexed (i-node), linked-list, and contiguous allocation."
	},
	{
			"question": "Which of the following delays / latencies is present in a traditional mechanical hard disk, but does not exist in a solid-state disk (SSD)?",
			"options": [
					"Virtualization time",
					"None of the alternatives is correct",
					"Transfer time",
					"Translation delay",
					"Rotational delay"
			],
			"answer": "Rotational delay",
			"explanation": "Rotational delay is a latency specific to traditional mechanical hard disks, where the disk must spin to the correct position. SSDs have no moving parts and therefore do not suffer from rotational delays."
	},
	{
			"question": "Which of the following devices is a typical character device?",
			"options": [
					"High-resolution display",
					"None of the alternatives is a character device",
					"Keyboard",
					"CD-ROM drive",
					"Solid-state disk"
			],
			"answer": "Keyboard",
			"explanation": "Character devices, like keyboards, transmit data one character at a time, in contrast to block devices, which manage data in fixed-size blocks."
	},
	{
			"question": "Which of the following devices is a typical block device?",
			"options": [
					"Solid-state disk",
					"Keyboard",
					"Line printer",
					"High-resolution display",
					"None of the alternatives is a block device"
			],
			"answer": "Solid-state disk",
			"explanation": "Block devices, like solid-state disks, store data in fixed-size blocks and allow the system to read and write entire blocks at a time, unlike character devices like keyboards that handle data streams one character at a time."
	}
]
